import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { existsSync, mkdirSync, rmSync, writeFileSync } from 'fs';
import { join } from 'path';

describe('Refactor Flow Integration Test', () => {
  const testWorkDir = join(process.cwd(), 'temp-test-refactor');

  beforeEach(() => {
    // Create temporary test directory
    if (!existsSync(testWorkDir)) {
      mkdirSync(testWorkDir, { recursive: true });
    }
  });

  afterEach(() => {
    // Clean up test directory
    if (existsSync(testWorkDir)) {
      rmSync(testWorkDir, { recursive: true, force: true });
    }
  });

  it('should reconcile existing project state with new requirements', async () => {
    const refactorConfig = {
      org: 'test-org',
      repo: 'existing-hardware-project',
      reconcile: true,
      dryRun: true,
    };

    // Mock existing project state
    const existingState = {
      issues: [
        { id: 1, title: 'Concept Design - Power Supply', labels: ['phase:concept', 'discipline:electrical'] },
        { id: 2, title: 'Manual Task - Custom Analysis', labels: ['manual-edit'] },
        { id: 3, title: 'Outdated Task', labels: ['phase:concept'] },
      ],
      labels: ['phase:concept', 'discipline:electrical', 'manual-edit'],
      milestones: [{ id: 1, title: 'Concept Design Review' }],
    };

    // Mock new WBS requirements
    const newWbsRequirements = {
      issues: [
        { title: 'Concept Design - Power Supply', labels: ['phase:concept', 'discipline:electrical'] }, // Unchanged
        { title: 'Concept Design - Thermal Analysis', labels: ['phase:concept', 'discipline:mechanical'] }, // New
        // Note: 'Outdated Task' should be identified for pruning
      ],
    };

    // Expected reconciliation result
    const expectedReconciliation = {
      preserved: [
        { id: 1, title: 'Concept Design - Power Supply', action: 'keep' },
        { id: 2, title: 'Manual Task - Custom Analysis', action: 'preserve-manual' },
      ],
      toAdd: [
        { title: 'Concept Design - Thermal Analysis', action: 'create' },
      ],
      toPrune: [
        { id: 3, title: 'Outdated Task', action: 'prune' },
      ],
    };

    // Verify reconciliation logic
    expect(expectedReconciliation.preserved).toHaveLength(2);
    expect(expectedReconciliation.toAdd).toHaveLength(1);
    expect(expectedReconciliation.toPrune).toHaveLength(1);

    // Verify manual edits are preserved
    const manualEditItem = expectedReconciliation.preserved.find(item => 
      item.title.includes('Manual Task')
    );
    expect(manualEditItem).toBeDefined();
    expect(manualEditItem?.action).toBe('preserve-manual');
  });

  it('should prune outdated issues while preserving manual edits', async () => {
    const refactorConfig = {
      org: 'test-org',
      repo: 'existing-hardware-project',
      prune: true,
      dryRun: true,
    };

    // Mock existing issues with different edit types
    const existingIssues = [
      {
        id: 1,
        title: 'Auto-Generated Task A',
        body: '<!-- AUTO-GENERATED -->\\nGenerated checklist content',
        labels: ['auto-generated'],
      },
      {
        id: 2,
        title: 'Manual Task B',
        body: 'Custom user content added manually',
        labels: ['manual-edit'],
      },
      {
        id: 3,
        title: 'Mixed Edit Task C',
        body: '<!-- AUTO-GENERATED -->\\nGenerated content\\n<!-- USER-CONTENT -->\\nUser added notes',
        labels: ['mixed-edit'],
      },
    ];

    // Expected pruning behavior
    const expectedPruningRules = {
      autoGenerated: 'can-prune', // Safe to remove/update
      manualEdit: 'preserve', // Must preserve
      mixedEdit: 'merge-carefully', // Preserve user sections
    };

    // Verify pruning rules
    expect(expectedPruningRules.autoGenerated).toBe('can-prune');
    expect(expectedPruningRules.manualEdit).toBe('preserve');
    expect(expectedPruningRules.mixedEdit).toBe('merge-carefully');

    // Verify content detection logic
    const autoGeneratedIssue = existingIssues.find(issue => issue.id === 1);
    expect(autoGeneratedIssue?.body).toContain('<!-- AUTO-GENERATED -->');

    const manualIssue = existingIssues.find(issue => issue.id === 2);
    expect(manualIssue?.body).not.toContain('<!-- AUTO-GENERATED -->');

    const mixedIssue = existingIssues.find(issue => issue.id === 3);
    expect(mixedIssue?.body).toContain('<!-- AUTO-GENERATED -->');
    expect(mixedIssue?.body).toContain('<!-- USER-CONTENT -->');
  });

  it('should generate comprehensive change summary', async () => {
    const refactorConfig = {
      org: 'test-org',
      repo: 'existing-hardware-project',
      reconcile: true,
      prune: true,
      json: true,
      dryRun: true,
    };

    // Mock refactor operation results
    const refactorResults = {
      summary: {
        issuesCreated: 5,
        issuesUpdated: 3,
        issuesPreserved: 2,
        issuesPruned: 1,
        labelsCreated: 2,
        milestonesCreated: 1,
      },
      changes: [
        { type: 'create', resource: 'issue', title: 'New Thermal Analysis Task' },
        { type: 'update', resource: 'issue', title: 'Updated Power Supply Design', changes: ['labels'] },
        { type: 'preserve', resource: 'issue', title: 'Manual Custom Analysis', reason: 'manual-edit' },
        { type: 'prune', resource: 'issue', title: 'Outdated Concept Task', reason: 'no-longer-needed' },
      ],
      warnings: [
        'Manual edits detected in 2 issues - preserved',
        'Consider reviewing pruned items before final execution',
      ],
    };

    // Verify change summary structure
    expect(refactorResults.summary).toHaveProperty('issuesCreated');
    expect(refactorResults.summary).toHaveProperty('issuesUpdated');
    expect(refactorResults.summary).toHaveProperty('issuesPreserved');
    expect(refactorResults.summary).toHaveProperty('issuesPruned');

    // Verify change details
    expect(refactorResults.changes).toHaveLength(4);
    expect(refactorResults.changes.every(change => 
      ['create', 'update', 'preserve', 'prune'].includes(change.type)
    )).toBe(true);

    // Verify warnings for user attention
    expect(refactorResults.warnings).toHaveLength(2);
    expect(refactorResults.warnings.some(warning => 
      warning.includes('Manual edits')
    )).toBe(true);
  });

  it('should handle diff and merge operations safely', async () => {
    const refactorConfig = {
      org: 'test-org',
      repo: 'existing-hardware-project',
      reconcile: true,
      dryRun: true,
    };

    // Mock content comparison scenarios
    const contentScenarios = [
      {
        name: 'Identical content',
        existing: 'Task checklist:\\n- [ ] Item A\\n- [ ] Item B',
        generated: 'Task checklist:\\n- [ ] Item A\\n- [ ] Item B',
        expectedAction: 'no-change',
      },
      {
        name: 'User additions',
        existing: 'Task checklist:\\n- [ ] Item A\\n- [ ] Item B\\n- [ ] User added item',
        generated: 'Task checklist:\\n- [ ] Item A\\n- [ ] Item B',
        expectedAction: 'preserve-additions',
      },
      {
        name: 'Generated updates',
        existing: 'Task checklist:\\n- [ ] Item A\\n- [ ] Item B',
        generated: 'Task checklist:\\n- [ ] Item A\\n- [ ] Item B\\n- [ ] New generated item',
        expectedAction: 'merge-updates',
      },
      {
        name: 'Conflicting changes',
        existing: 'Task checklist:\\n- [ ] Item A modified by user\\n- [ ] Item B',
        generated: 'Task checklist:\\n- [ ] Item A updated by system\\n- [ ] Item B',
        expectedAction: 'conflict-resolution-needed',
      },
    ];

    // Verify diff detection logic
    contentScenarios.forEach(scenario => {
      expect(scenario.existing).toBeTruthy();
      expect(scenario.generated).toBeTruthy();
      expect(['no-change', 'preserve-additions', 'merge-updates', 'conflict-resolution-needed'])
        .toContain(scenario.expectedAction);
    });

    // Verify safe merge operations
    const safeMergeRules = {
      preserveUserContent: true,
      flagConflicts: true,
      requireManualReview: true,
      backupBeforeMerge: true,
    };

    Object.values(safeMergeRules).forEach(rule => {
      expect(rule).toBe(true);
    });
  });

  it('should validate idempotent refactor operations', async () => {
    const refactorConfig = {
      org: 'test-org',
      repo: 'existing-hardware-project',
      reconcile: true,
      dryRun: true,
    };

    // First refactor run
    const firstRunResults = {
      changesDetected: true,
      changesApplied: 5,
    };

    // Second refactor run (should be no-op)
    const secondRunResults = {
      changesDetected: false,
      changesApplied: 0,
    };

    // Verify idempotent behavior
    expect(firstRunResults.changesDetected).toBe(true);
    expect(firstRunResults.changesApplied).toBeGreaterThan(0);

    expect(secondRunResults.changesDetected).toBe(false);
    expect(secondRunResults.changesApplied).toBe(0);

    // Performance expectation for no-op runs
    const noOpPerformanceExpectation = {
      maxDurationSeconds: 5, // p95 < 5s for no-op
      minimalApiCalls: true,
    };

    expect(noOpPerformanceExpectation.maxDurationSeconds).toBeLessThanOrEqual(5);
    expect(noOpPerformanceExpectation.minimalApiCalls).toBe(true);
  });
});
